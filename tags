!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BLOCKSIZE	include/settings.h	14;"	d
BLOCKT	include/settings.h	20;"	d
CC	Makefile	/^CC=gcc$/;"	m
CC	algorithm/normal/Makefile	/^CC=gcc$/;"	m
CC	lower/posix/Makefile	/^CC=gcc$/;"	m
FSTYPE	include/settings.h	18;"	d
FS_DELETE_T	include/types.h	6;"	d
FS_GET_T	include/types.h	4;"	d
FS_SET_T	include/types.h	5;"	d
FS_free	include/FS.c	/^void FS_free(void *ptr,int tag){$/;"	f
FS_malloc	include/FS.c	/^int FS_malloc(void **ptr, int size){$/;"	f
G	include/settings.h	7;"	d
K	include/settings.h	5;"	d
KEYT	include/settings.h	19;"	d
M	include/settings.h	6;"	d
MIXED	include/settings.h	/^	MIXED$/;"	e	enum:__anon4
NOB	include/container.h	/^	uint32_t NOB;$/;"	m	struct:lower_info
NOP	include/container.h	/^	uint32_t NOP;$/;"	m	struct:lower_info
P	include/settings.h	9;"	d
PAGESIZE	include/settings.h	12;"	d
PPB	include/container.h	/^	uint32_t PPB;$/;"	m	struct:lower_info
PWD	Makefile	/^PWD=$(pwd)$/;"	m
QSIZE	include/settings.h	24;"	d
RANDGET	include/settings.h	/^	RANDGET,RANDSET,$/;"	e	enum:__anon4
RANDSET	include/settings.h	/^	RANDGET,RANDSET,$/;"	e	enum:__anon4
SEQGET	include/settings.h	/^	SEQGET,SEQSET,$/;"	e	enum:__anon4
SEQSET	include/settings.h	/^	SEQGET,SEQSET,$/;"	e	enum:__anon4
SOB	include/container.h	/^	uint32_t SOB;$/;"	m	struct:lower_info
SOK	include/container.h	/^	uint32_t SOK;$/;"	m	struct:lower_info
SOP	include/container.h	/^	uint32_t SOP;$/;"	m	struct:lower_info
SYNC	include/settings.h	23;"	d
T	include/settings.h	8;"	d
TARGETOBJ	Makefile	/^TARGETOBJ =\\$/;"	m
TARGETOBJ	algorithm/normal/Makefile	/^TARGETOBJ:=\\$/;"	m
TARGETOBJ	lower/posix/Makefile	/^TARGETOBJ:=\\$/;"	m
TARGET_ALGO	Makefile	/^TARGET_ALGO=normal$/;"	m
TARGET_LOWER	Makefile	/^TARGET_LOWER=posix$/;"	m
THREADSIZE	include/settings.h	25;"	d
TOTALSIZE	include/settings.h	11;"	d
TS	include/container.h	/^	uint64_t TS;$/;"	m	struct:lower_info
V_PTR	include/settings.h	21;"	d
_LARGEFILE64_SOURCE	lower/posix/posix.c	9;"	d	file:
_NOB	include/settings.h	15;"	d
_NOP	include/settings.h	16;"	d
_PPB	include/settings.h	13;"	d
__H_CONTAINER__	include/container.h	2;"	d
__H_FS__	include/FS.h	2;"	d
__H_INTERFACE_H	interface/interface.h	2;"	d
__H_QUEUE__	interface/queue.h	2;"	d
__H_SETTING__	include/settings.h	2;"	d
__H_TYPES__	include/types.h	2;"	d
__normal	algorithm/normal/normal.c	/^struct algorithm __normal={$/;"	v	typeref:struct:algorithm
__posix	lower/posix/posix.c	/^lower_info __posix={$/;"	v
_fd	lower/posix/posix.c	/^static int _fd;$/;"	v	file:
algo	interface/threading.h	/^	algorithm *algo;$/;"	m	struct:master_processor
algo_body	include/container.h	/^	void *algo_body;$/;"	m	struct:algorithm
algorithm	include/container.h	/^struct algorithm{$/;"	s
algorithm	include/container.h	/^typedef struct algorithm algorithm;$/;"	t	typeref:struct:algorithm
assign_req	interface/interface.c	/^static void assign_req(request* req){$/;"	f	file:
bench_clean	bench/bench.c	/^void bench_clean(){$/;"	f
bench_init	bench/bench.c	/^void bench_init(bench_type type, int start, int end, int number){$/;"	f
bench_type	include/settings.h	/^}bench_type;$/;"	t	typeref:enum:__anon4
bench_value	bench/bench.h	/^}bench_value;$/;"	t	typeref:struct:__anon1
block_bad	include/types.h	/^	block_bad,$/;"	e	enum:__anon5
block_empty	include/types.h	/^	block_empty,$/;"	e	enum:__anon5
block_full	include/types.h	/^	block_full,$/;"	e	enum:__anon5
block_he	include/types.h	/^	block_he$/;"	e	enum:__anon5
body	bench/bench.c	/^bench_value *body;$/;"	v
body	bench/bench.h	/^	bench_value *body;$/;"	m	struct:__anon2
bool	include/settings.h	/^typedef enum{false,true} bool;$/;"	t	typeref:enum:__anon3
create	include/container.h	/^	uint32_t (*create) (lower_info*,struct algorithm *);$/;"	m	struct:algorithm
create	include/container.h	/^	uint32_t (*create)(struct lower_info*);$/;"	m	struct:lower_info
destroy	include/container.h	/^	void (*destroy) (lower_info*, struct algorithm *);$/;"	m	struct:algorithm
destroy	include/container.h	/^	void* (*destroy)(struct lower_info*);$/;"	m	struct:lower_info
end_req	include/container.h	/^	bool (*end_req)(struct request*);$/;"	m	struct:request
false	include/settings.h	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3
flag	interface/threading.h	/^	pthread_mutex_t flag;$/;"	m	struct:master_processor
flag	interface/threading.h	/^	pthread_mutex_t flag;$/;"	m	struct:processor
free_bench_all	bench/bench.c	/^void free_bench_all(){$/;"	f
free_bench_one	bench/bench.c	/^void free_bench_one(bench_value*){$/;"	f
get	include/container.h	/^	uint32_t (*get)(request *);$/;"	m	struct:algorithm
get_bench	bench/bench.c	/^bench_value* get_bench(){$/;"	f
head	interface/queue.h	/^	node *head;$/;"	m	struct:queue
inf_end_req	interface/interface.c	/^bool inf_end_req(request *req){$/;"	f
inf_free	interface/interface.c	/^void inf_free(){$/;"	f
inf_init	interface/interface.c	/^void inf_init(){$/;"	f
inf_make_req	interface/interface.c	/^bool inf_make_req(const FSTYPE type, const KEYT key, const V_PTR value){$/;"	f
inf_make_req_Async	interface/interface.c	/^bool inf_make_req_Async(void *ureq, void *(*end_req)(void*)){$/;"	f
inf_print_debug	interface/interface.c	/^void inf_print_debug(){$/;"	f
isAsync	include/container.h	/^	bool isAsync;$/;"	m	struct:request
key	bench/bench.h	/^	KEYT key;$/;"	m	struct:__anon1
key	include/container.h	/^	KEYT key;$/;"	m	struct:request
key	include/container.h	/^	const KEYT key; $/;"	m	struct:upper_request
li	include/container.h	/^	lower_info* li;$/;"	m	struct:algorithm
li	interface/threading.h	/^	lower_info *li;$/;"	m	struct:master_processor
lower_info	include/container.h	/^struct lower_info {$/;"	s
lower_info	include/container.h	/^typedef struct lower_info lower_info;$/;"	t	typeref:struct:lower_info
lower_status	include/types.h	/^}lower_status;$/;"	t	typeref:enum:__anon5
main	interface/main.c	/^int main(){$/;"	f
master	interface/threading.h	/^	master_processor *master;$/;"	m	struct:processor
master_processor	interface/threading.h	/^struct master_processor{$/;"	s
master_processor	interface/threading.h	/^typedef struct master_processor master_processor;$/;"	t	typeref:struct:master_processor
monitor	bench/bench.h	/^}monitor;$/;"	t	typeref:struct:__anon2
mp	interface/interface.c	/^master_processor mp;$/;"	v
next	interface/queue.h	/^	struct node *next;$/;"	m	struct:node	typeref:struct:node::node
node	interface/queue.h	/^typedef struct node{$/;"	s
node	interface/queue.h	/^}node;$/;"	t	typeref:struct:node
normal_create	algorithm/normal/normal.c	/^uint32_t normal_create (lower_info* li,algorithm *algo){$/;"	f
normal_destroy	algorithm/normal/normal.c	/^void normal_destroy (lower_info* li, algorithm *algo){$/;"	f
normal_get	algorithm/normal/normal.c	/^bool normal_get(request *req){$/;"	f
normal_remove	algorithm/normal/normal.c	/^bool normal_remove(request *req){$/;"	f
normal_set	algorithm/normal/normal.c	/^bool normal_set(request *req){$/;"	f
p_main	interface/interface.c	/^void *p_main(void *__input){$/;"	f
params	include/container.h	/^	void **params;$/;"	m	struct:request
posix_create	lower/posix/posix.c	/^uint32_t posix_create(lower_info *li){$/;"	f
posix_destroy	lower/posix/posix.c	/^void *posix_destroy(lower_info *li){$/;"	f
posix_pull_data	lower/posix/posix.c	/^void *posix_pull_data(KEYT PPA, uint32_t size, const V_PTR value, bool async, request *req, uint32_t dmatag){$/;"	f
posix_push_data	lower/posix/posix.c	/^void *posix_push_data(KEYT PPA, uint32_t size, const V_PTR value, bool async, request *req, uint32_t dmatag){$/;"	f
posix_stop	lower/posix/posix.c	/^void posix_stop(){}$/;"	f
posix_trim_block	lower/posix/posix.c	/^void *posix_trim_block(KEYT PPA, bool async){$/;"	f
processor	interface/threading.h	/^typedef struct processor{$/;"	s
processor	interface/threading.h	/^}processor;$/;"	t	typeref:struct:processor
processors	interface/threading.h	/^	processor *processors;$/;"	m	struct:master_processor
pull_data	include/container.h	/^	void* (*pull_data)(KEYT ppa, uint32_t size, const V_PTR value,bool async,request *req,uint32_t dmatag);$/;"	m	struct:lower_info
push_data	include/container.h	/^	void* (*push_data)(KEYT ppa, uint32_t size, const V_PTR value,bool async,request *req,uint32_t dmatag);$/;"	m	struct:lower_info
q_dequeue	interface/queue.c	/^const request * q_dequeue(queue *q){$/;"	f
q_enqueue	interface/queue.c	/^bool q_enqueue(const request* req, queue* q){$/;"	f
q_free	interface/queue.c	/^void q_free(queue* q){$/;"	f
q_init	interface/queue.c	/^void q_init(queue **q){$/;"	f
q_lock	interface/queue.h	/^	pthread_mutex_t q_lock;$/;"	m	struct:queue
queue	interface/queue.h	/^typedef struct queue{$/;"	s
queue	interface/queue.h	/^}queue;$/;"	t	typeref:struct:queue
remove	include/container.h	/^	uint32_t (*remove)(request*);$/;"	m	struct:algorithm
req	interface/queue.h	/^	const request *req;$/;"	m	struct:node
req_q	interface/threading.h	/^	queue *req_q;$/;"	m	struct:processor
request	include/container.h	/^typedef struct request {$/;"	s
request	include/container.h	/^}request;$/;"	t	typeref:struct:request
seqget	bench/bench.c	/^void seqget(int start, int end, int number){$/;"	f
seqset	bench/bench.c	/^void seqset(int start, int end, int number){$/;"	f
set	include/container.h	/^	uint32_t (*set)(request *);$/;"	m	struct:algorithm
size	interface/queue.h	/^	int size;$/;"	m	struct:queue
statusOfblock	include/container.h	/^	lower_status (*statusOfblock)(BLOCKT);$/;"	m	struct:lower_info
stop	include/container.h	/^	void (*stop)();$/;"	m	struct:lower_info
stopflag	interface/threading.h	/^	bool stopflag;$/;"	m	struct:master_processor
t_id	interface/threading.h	/^	pthread_t t_id;$/;"	m	struct:processor
tail	interface/queue.h	/^	node *tail;$/;"	m	struct:queue
trim_block	include/container.h	/^	void* (*trim_block)(KEYT ppa,bool async);$/;"	m	struct:lower_info
true	include/settings.h	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3
type	bench/bench.h	/^	FSTYPE type;$/;"	m	struct:__anon1
type	include/container.h	/^	FSTYPE type;$/;"	m	struct:request
type	include/container.h	/^	const FSTYPE type;$/;"	m	struct:upper_request
upper_end	include/container.h	/^	void *(*upper_end)(void *);$/;"	m	struct:request
upper_req	include/container.h	/^	void *upper_req;$/;"	m	struct:request
upper_request	include/container.h	/^typedef struct upper_request{$/;"	s
upper_request	include/container.h	/^}upper_request;$/;"	t	typeref:struct:upper_request
value	bench/bench.h	/^	V_PTR value;$/;"	m	struct:__anon1
value	include/container.h	/^	V_PTR value;$/;"	m	struct:request
value	include/container.h	/^	const V_PTR value;$/;"	m	struct:upper_request
